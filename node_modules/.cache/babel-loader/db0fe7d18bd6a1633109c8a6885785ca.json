{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst path = require('path');\n\nconst mkdirsSync = require('../mkdirs').mkdirsSync;\n\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync;\n\nconst stat = require('../util/stat');\n\nfunction copySync(src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n  // Warn about using preserveTimestamps on 32-bit node\n\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`);\n  }\n\n  const {\n    srcStat,\n    destStat\n  } = stat.checkPathsSync(src, dest, 'copy', opts);\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy');\n  return handleFilterAndCopy(destStat, src, dest, opts);\n}\n\nfunction handleFilterAndCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent);\n  return getStats(destStat, src, dest, opts);\n}\n\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  return getStats(destStat, src, dest, opts);\n}\n\nfunction getStats(destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;\n  const srcStat = statSync(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n  throw new Error(`Unknown file: ${src}`);\n}\n\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n  return mayCopyFile(srcStat, src, dest, opts);\n}\n\nfunction mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest);\n    return copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}\n\nfunction copyFile(srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest);\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);\n  return setDestMode(dest, srcStat.mode);\n}\n\nfunction handleTimestamps(srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);\n  return setDestTimestamps(src, dest);\n}\n\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\n\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200);\n}\n\nfunction setDestMode(dest, srcMode) {\n  return fs.chmodSync(dest, srcMode);\n}\n\nfunction setDestTimestamps(src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src);\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}\n\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  return copyDir(src, dest, opts);\n}\n\nfunction mkDirAndCopy(srcMode, src, dest, opts) {\n  fs.mkdirSync(dest);\n  copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}\n\nfunction copyDir(src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));\n}\n\nfunction copyDirItem(item, src, dest, opts) {\n  const srcItem = path.join(src, item);\n  const destItem = path.join(dest, item);\n  const {\n    destStat\n  } = stat.checkPathsSync(srcItem, destItem, 'copy', opts);\n  return startCopy(destStat, srcItem, destItem, opts);\n}\n\nfunction onLink(destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src);\n\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest);\n  } else {\n    let resolvedDest;\n\n    try {\n      resolvedDest = fs.readlinkSync(dest);\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);\n      throw err;\n    }\n\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest);\n    }\n\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n    } // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n\n\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n    }\n\n    return copyLink(resolvedSrc, dest);\n  }\n}\n\nfunction copyLink(resolvedSrc, dest) {\n  fs.unlinkSync(dest);\n  return fs.symlinkSync(resolvedSrc, dest);\n}\n\nmodule.exports = copySync;","map":{"version":3,"sources":["/home/carlos/Documents/Software3/FrontendProyectoSoftware3/node_modules/fs-extra/lib/copy-sync/copy-sync.js"],"names":["fs","require","path","mkdirsSync","utimesMillisSync","stat","copySync","src","dest","opts","filter","clobber","overwrite","preserveTimestamps","process","arch","console","warn","srcStat","destStat","checkPathsSync","checkParentPathsSync","handleFilterAndCopy","destParent","dirname","existsSync","getStats","startCopy","statSync","dereference","lstatSync","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","Error","isFIFO","copyFile","mayCopyFile","unlinkSync","errorOnExist","copyFileSync","handleTimestamps","mode","setDestMode","srcMode","fileIsNotWritable","makeFileWritable","setDestTimestamps","chmodSync","updatedSrcStat","atime","mtime","mkDirAndCopy","copyDir","mkdirSync","readdirSync","forEach","item","copyDirItem","srcItem","join","destItem","resolvedSrc","readlinkSync","resolve","cwd","symlinkSync","resolvedDest","err","code","isSrcSubdir","copyLink","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n"]},"metadata":{},"sourceType":"script"}