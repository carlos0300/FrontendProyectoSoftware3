{"ast":null,"code":"'use strict';\n\nconst fs = require('../fs');\n\nconst path = require('path');\n\nconst util = require('util');\n\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? file => fs.stat(file, {\n    bigint: true\n  }) : file => fs.lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    if (err.code === 'ENOENT') return null;\n    throw err;\n  })]).then(_ref => {\n    let [srcStat, destStat] = _ref;\n    return {\n      srcStat,\n      destStat\n    };\n  });\n}\n\nfunction getStatsSync(src, dest, opts) {\n  let destStat;\n  const statFunc = opts.dereference ? file => fs.statSync(file, {\n    bigint: true\n  }) : file => fs.lstatSync(file, {\n    bigint: true\n  });\n  const srcStat = statFunc(src);\n\n  try {\n    destStat = statFunc(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n\n  return {\n    srcStat,\n    destStat\n  };\n}\n\nfunction checkPaths(src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src);\n        const destBaseName = path.basename(dest);\n\n        if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, {\n            srcStat,\n            destStat,\n            isChangingCase: true\n          });\n        }\n\n        return cb(new Error('Source and destination must not be the same.'));\n      }\n\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));\n      }\n\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n\n    return cb(null, {\n      srcStat,\n      destStat\n    });\n  });\n}\n\nfunction checkPathsSync(src, dest, funcName, opts) {\n  const {\n    srcStat,\n    destStat\n  } = getStatsSync(src, dest, opts);\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src);\n      const destBaseName = path.basename(dest);\n\n      if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return {\n          srcStat,\n          destStat,\n          isChangingCase: true\n        };\n      }\n\n      throw new Error('Source and destination must not be the same.');\n    }\n\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);\n    }\n\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n\n  return {\n    srcStat,\n    destStat\n  };\n} // recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\n\n\nfunction checkParentPaths(src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();\n  fs.stat(destParent, {\n    bigint: true\n  }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb();\n      return cb(err);\n    }\n\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n\n    return checkParentPaths(src, srcStat, destParent, funcName, cb);\n  });\n}\n\nfunction checkParentPathsSync(src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  let destStat;\n\n  try {\n    destStat = fs.statSync(destParent, {\n      bigint: true\n    });\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n}\n\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n} // return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\n\n\nfunction isSrcSubdir(src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i);\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i);\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);\n}\n\nfunction errMsg(src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n};","map":{"version":3,"sources":["/home/carlos/Documents/Software3/FrontendProyectoSoftware3/node_modules/fs-extra/lib/util/stat.js"],"names":["fs","require","path","util","getStats","src","dest","opts","statFunc","dereference","file","stat","bigint","lstat","Promise","all","catch","err","code","then","srcStat","destStat","getStatsSync","statSync","lstatSync","checkPaths","funcName","cb","callbackify","stats","areIdentical","srcBaseName","basename","destBaseName","toLowerCase","isChangingCase","Error","isDirectory","isSrcSubdir","errMsg","checkPathsSync","checkParentPaths","srcParent","resolve","dirname","destParent","parse","root","checkParentPathsSync","ino","dev","srcArr","split","sep","filter","i","destArr","reduce","acc","cur","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src)\n        const destBaseName = path.basename(dest)\n        if (funcName === 'move' &&\n          srcBaseName !== destBaseName &&\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, { srcStat, destStat, isChangingCase: true })\n        }\n        return cb(new Error('Source and destination must not be the same.'))\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  })\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n}\n"]},"metadata":{},"sourceType":"script"}